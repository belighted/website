lang: "en"
slug: "how-we-test-our-rails-projects-1-3"
originalPath: "https://www.belighted.com/blog/how-we-test-our-rails-projects-1-3"
article:
  title: "How we test our Rails projects (1/3)"
  content: "<span id=\"hs_cos_wrapper_post_body\" class=\"hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text\" data-hs-cos-general-type=\"meta_field\" data-hs-cos-type=\"rich_text\"><h2>Introduction</h2>\n<p>This series of blog posts will explain how we write automatic tests for our Rails projects. It will be split in 3 parts discussing the following topics :</p>\n<!--more-->\n\n<p>Having automatic tests is an <strong>idea</strong> everybody finds great but very often the concretization of that idea is difficult. Tests take time to be written, tend to be an obstacle when the code needs to be changed, and need their own maintenance. When a project grows, so does the test suite and so does the time to run it, making the suite <strong>feel</strong> less valuable.</p>\n<p>We hope that sharing with you some of our test habits will make your tests less of a <em>burden</em> and more of an <em>asset</em>.</p>\n<h2>Part 1 : The tools</h2>\n\n<p>First of all we need a test framework. Ruby comes bundled with Minitest which had some great improvements in the last few years, but since we have a working stack with RSpec there is no reason for us to fix it if it ain't broken.</p>\n<p>RSpec biggest strength is also its biggest weakness : its DSL. When you read or write it for the first time, you do not have the feeling of writing ruby. You don't see directly where are your modules, classes, method definition and method calls which make it difficult to leverage some of your coding techniques but on the other hand almost all the abstraction you need have already been abstracted and the few additional you might are pluggable in a clearly documented way.</p>\n<p>RSpec is a testing framework where Minitest is a testing library.</p>\n<p>RSpec covers : Writing specs, Running specs, Creating test doubles, Verifying assertions, Creating new assertions, Creating example contexts, ...</p>\n<p>Internally, RSpec is splitted in several sub projects making it possible to only pick some parts but we always take the whole package including RSpec Core, RSpec Expectations, RSpec Mocks, RSpec Rails.</p>\n\n<p>When writing specs in a rails application, you certainly will end up writing data in a database.</p>\n<p>Obviously it's not always the case, and it should not be the case when writing isolation specs for instance but when you're verifying an ActiveRecord object or when you're writing a smoke test, you will probably have to persist some data.</p>\n<p>RSpec already offers to wrap every example in a transaction which is a very good strategy but it's not enough once you start writing feature specs using a real browser.</p>\n<p>In those cases you need two processes sharing data through the database, thus you cannot use a transaction.</p>\n<p>DatabaseCleaner is a tiny tool allowing to choose what strategy you want depending on the test, therefore you can use a transaction strategy for almost all your tests and a truncation strategy for your feature specs.</p>\n<p>If you have to manage multiple databases or datastores, this tool offers you a central configuration to manage their cleaning between specs.</p>\n\n<p>Capybara is a set of tools for manipulating an html page like a user would do. It works with multiple drivers ( a driver is a way to hold a page, send request and receive responses), but we will only use two : the default <strong>rack-test</strong> driver which is like a fake in-memory browser with no support for css or javascript, and <strong>poltergeist</strong> which is a driver delegating to a <strong><a href=\"https://phantomjs.org/\">phantomjs</a> </strong>process.</p>\n<p>Capybara is a tool enabling us to write scenarios using abstraction like \"click that button\" or \"visit that url\", instead of \"send a PUT request whith that formdata payload\" or \"send a GET request with those headers\". The objective is to be much closer to describing the user intent, which is the point of a user story.</p>\n\n<p>SitePrism is again a tiny library which is great because it fits perfectly its small purpose. This library sits on top of capybara and its goal is to allow you to write <strong>page objects</strong>. A page object is an object allowing you to easily manipulate a page from a feature spec without having to know the characteristics of that page. It also enables you to put that knowledge in a ruby class and then use the page objects in every feature spec going through that page.</p>\n<p>Imagine how many user stories must go through the login page, then imagine your login page has changed just a little bit and requires an additional click, or the css class you used to target the login field has changed. You wouldn't want to edit all your stories and you shouldn't have to. ! Your stories haven't changed, the page has. With the help of a page object, the scenarios capture the behaviour of the user and the page objects translate them into page manipulation.</p>\n\n<p>This one is more about sugar on the cake but I've really come to enjoy it a lot. This gem will automatically take a screenshot of every failed feature spec when the failure happened. If the spec driver was rack-test, then the screenshot take the form of an html page, if you were using poltergeist then you have both an html file and a png image.</p>\n<p>That's all it does.</p>\n<p>And it's incredibely useful when you've just rerun a suite of 40 feature spec expecting them to pass (because if you're working on your feature and do not expect your spec to pass, then you should probably not run 40 of them together) and 2 out of the 40 failed. When that happens, it's really cool to not have to rerun the failed ones in order to understand what went wrong but already have the error message AND the screenshots available.</p>\n<p>If you don't like the automatic screenshot feature, this gem is still awesome for it's ability to take and open a screenshot when running a scenario step by step in a debugger.</p>\n\n<p>When writing specs, one always needs data.</p>\n<p>Sometimes that data is a quite simple structure : a String, a Hash, a Message, ... Sometimes we need a very complex graph of data : An invoice with an attached user having a premium plan, A thread with 4 messages and 10 comments each having different authors, ...</p>\n<p>When facing the second case, we often have to provide details for building valid data structures but most of those details are irrelevant for the test.</p>\n<p>This is where Factory Girl can be used. The point of this tool is to help building complex graphs of valid objects by only specifying what is useful for the current test and let the factory <em>fill</em> the other details with whatever is required to make those objects valid.</p>\n<p>This tool helps to drastically reduce the noise in your test.</p>\n<p>It is so easy to use that you might overuse it by requesting a complex graph when you could have done your spec with a simple object. The point of Factory Girl is not to be the only way for you to generate data for your test, the point is to have an easy, inconspicuous way of building complex graphs. And it does that very effectively.</p>\n<p>Update : the next part is ready, you can find it<strong> <a href=\"https://belighted.com/blog/how-we-test-our-rails-projects-2-3\">here</a></strong>, you can also go directly to the <strong><a href=\"https://belighted.com/blog/how-we-test-our-rails-projects-3-3\">last part<br></a></strong></p>\n<p><strong><!--HubSpot Call-to-Action Code --><span class=\"hs-cta-wrapper\" id=\"hs-cta-wrapper-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\"><span class=\"hs-cta-node hs-cta-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\" id=\"hs-cta-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\"><!--[if lte IE 8]><div id=\"hs-cta-ie-element\"></div><![endif]--><a href=\"https://cta-redirect.hubspot.com/cta/redirect/1684659/fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\" target=\"_blank\"><img class=\"hs-cta-img\" id=\"hs-cta-img-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\" src=\"https://no-cache.hubspot.com/cta/default/1684659/fb3606cc-cc1b-47d0-ae85-2c9f69837fe2.png\" alt=\"New Call-to-action\"></a></span></span><!-- end HubSpot Call-to-Action Code --></strong></p>\n</span>"
  textBody: ""
  html: "<!--<![endif]--><head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"author\" content=\"Philippe V.\">\n    <meta name=\"description\" content=\"First of a series of 3 articles about how we write automatic tests for our rails projects. \nThis article focuses on the tools we use.\">\n    <meta name=\"generator\" content=\"HubSpot\">\n    <title>How we test our Rails projects (1/3)</title>\n    <link rel=\"shortcut icon\" href=\"https://www.belighted.com/hubfs/logo-belighted.png\">\n    \n\n    \n\n    <meta property=\"og:description\" content=\"First of a series of 3 articles about how we write automatic tests for our rails projects. \nThis article focuses on the tools we use.\">\n    <meta property=\"og:title\" content=\"How we test our Rails projects (1/3)\">\n    <meta name=\"twitter:description\" content=\"First of a series of 3 articles about how we write automatic tests for our rails projects. \nThis article focuses on the tools we use.\">\n    <meta name=\"twitter:title\" content=\"How we test our Rails projects (1/3)\">\n\n\n    <style>\na.cta_button{-moz-box-sizing:content-box !important;-webkit-box-sizing:content-box !important;box-sizing:content-box !important;vertical-align:middle}.hs-breadcrumb-menu{list-style-type:none;margin:0px 0px 0px 0px;padding:0px 0px 0px 0px}.hs-breadcrumb-menu-item{float:left;padding:10px 0px 10px 10px}.hs-breadcrumb-menu-divider:before{content:'â€º';padding-left:10px}.hs-featured-image-link{border:0}.hs-featured-image{float:right;margin:0 0 20px 20px;max-width:50%}@media (max-width: 568px){.hs-featured-image{float:none;margin:0;width:100%;max-width:100%}}.hs-screen-reader-text{clip:rect(1px, 1px, 1px, 1px);height:1px;overflow:hidden;position:absolute !important;width:1px}\n</style>\n\n<link rel=\"stylesheet\" href=\"/hs/hsstatic/AsyncSupport/static-1.70/sass/comments_listing_asset.css\">\n<link rel=\"stylesheet\" href=\"/hs/hsstatic/AsyncSupport/static-1.70/sass/rss_post_listing.css\">\n    \n\n    \n    \n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n\n<!-- Facebook Pixel Code -->\n\n<noscript>&lt;img  height=\"1\" width=\"1\" style=\"display:none\" src=\"https://www.facebook.com/tr?id=706355809571598&amp;amp;ev=PageView&amp;amp;noscript=1\"&gt;</noscript>\n<!-- End Facebook Pixel Code -->\n<link rel=\"amphtml\" href=\"https://www.belighted.com/blog/how-we-test-our-rails-projects-1-3?hs_amp=true\">\n\n<meta property=\"og:image\" content=\"https://belighted.com/images/default_blogpost_image_0@1x.jpg#keepProtocol\">\n\n<meta name=\"twitter:image\" content=\"https://belighted.com/images/default_blogpost_image_0@1x.jpg#keepProtocol\">\n\n\n<meta property=\"og:url\" content=\"https://www.belighted.com/blog/how-we-test-our-rails-projects-1-3\">\n<meta name=\"twitter:card\" content=\"summary\">\n\n<link rel=\"canonical\" href=\"https://www.belighted.com/blog/how-we-test-our-rails-projects-1-3\">\n\n<meta property=\"og:type\" content=\"article\">\n<link rel=\"alternate\" type=\"application/rss+xml\" href=\"https://www.belighted.com/blog/rss.xml\">\n<meta name=\"twitter:domain\" content=\"www.belighted.com\">\n\n\n<meta http-equiv=\"content-language\" content=\"en\">\n<link rel=\"stylesheet\" href=\"//cdn2.hubspot.net/hub/-1/hub_generated/template_assets/1495141902003/hubspot_default/shared/responsive/layout.min.css\">\n\n\n<link rel=\"stylesheet\" href=\"https://www.belighted.com/hs-fs/hub/1684659/hub_generated/template_assets/8523445462/1569881984337/Marketplace/Neambo/Act21/Coded_Files/Act21.min.css\">\n\n\n\n\n</head>\n<body class=\"blog-1 featured-image-right   hs-content-id-4792078262 hs-blog-post hs-blog-id-4544204069\" style=\"\"></body>"

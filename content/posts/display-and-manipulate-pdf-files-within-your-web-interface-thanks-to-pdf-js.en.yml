lang: "en"
slug: "display-and-manipulate-pdf-files-within-your-web-interface-thanks-to-pdf-js"
originalPath: "https://www.belighted.com/blog/display-and-manipulate-pdf-files-within-your-web-interface-thanks-to-pdf-js"
title: "Display and manipulate PDF files within your web interface thanks to PDF.js"
author: "St√©phane A."
description: "A short introduction to PDF.js which will guide you through the installation of this library aimed to manipulate PDF files within your web interface."
image: "https://belighted-website.s3.amazonaws.com/uploads/pdfjs.png#keepProtocol"
date: 1420070400000
body: "<h2>The business need</h2>\n<p>Lately one of our customer was struggling with a UX problem: their operational team used their web platform (powered by Rails) to manage a bunch of products, and they kept complaining about having to download every time the PDF file attached to each of these products only to have an overview of its content. Furthermore, they couldn't interact with the document (e.g. with things like annotations), which would provide a useful improvement to their process. After some time, our reflection lead to the idea of displaying the PDF directly within the web interface in order to meet our customer's expectations.</p>\n<!--more-->\n<h2>The implementation</h2>\n<p>Let's start with the beginning: the situation at that time was just a page providing a link to the PDF attached to a product.</p>\n<p>We had this route</p>\n<pre><code class=\"ruby\">resources <span class=\"symbol\">:products</span>\n</code></pre>\n<p>with the corresponding controller</p>\n<pre><code class=\"ruby\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductsController</span> <span class=\"inheritance\">&lt; <span class=\"parent\">ApplicationController</span></span></span>\n\n    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">show</span></span>\n      product = <span class=\"constant\">Product</span>.find(params[<span class=\"symbol\">:id</span>])\n      respond_to <span class=\"keyword\">do</span> |format|\n        format.pdf <span class=\"keyword\">do</span>\n          send_file product.file.path\n        <span class=\"keyword\">end</span>\n        format.html <span class=\"keyword\">do</span>\n          render <span class=\"symbol\">:show</span>\n        <span class=\"keyword\">end</span>\n      <span class=\"keyword\">end</span>\n    <span class=\"keyword\">end</span>\n<span class=\"keyword\">end</span>\n</code></pre>\n<p>and the model (using Paperclip to store files)</p>\n<pre><code class=\"ruby\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> <span class=\"inheritance\">&lt; <span class=\"parent\">ActiveRecord::Base</span></span></span>\n\n  has_attached_file <span class=\"symbol\">:file</span>\n  validates_attachment <span class=\"symbol\">:file</span>, content_type<span class=\"symbol\">:</span> { content_type<span class=\"symbol\">:</span> [<span class=\"string\">\"application/pdf\"</span>] }\n\n<span class=\"keyword\">end</span>\n</code></pre>\n<p>and the view which contained</p>\n<pre><code class=\"ruby\">&lt;%= link_to product_path(product, <span class=\"symbol\">:format</span> =&gt; <span class=\"symbol\">:pdf</span>) %&gt;\n</code></pre>\n<p>With this as our starting point, we simply choose to use the javascript library <a href=\"https://mozilla.github.io/pdf.js\">PDF.js</a> in order to display these PDFs.</p>\n<p>PDF.js is an open source project supported by Mozilla Labs. Its goal is to create a general-purpose, web standards-based platform for parsing and rendering PDFs.</p>\n<p>Maybe you haven't noticed but you've already met this library if you're a Firefox user because it's exactly what they use for their embedded PDF viewer.</p>\n<p>PDF.js is composed of three parts:</p>\n<ul>\n<li>The first and main one is the <code>pdf.js</code> file itself, which takes care of everything related to the parsing and handling of the PDF document, and which we'll use to manipulate the PDF.</li>\n<li>The second is the <code>pdf.worker.js</code> file which takes care of the document retrieval by doing a parallel request to the server.</li>\n<li>And finally there is the viewer. It is specific to the Firefox browser and it uses the 2 underlying libraries. It's this piece that we'll rewrite in order to achieve our goal.</li>\n</ul>\n<p>Let's start by including <code>pdf.js</code> as well as <code>pdf.worker.js</code> in our <code>assets/javascript/vendor</code> folder and require it in our <code>application.js</code> manifest.</p>\n<pre><code class=\"ruby\">/<span class=\"regexp\">/= require vendor/pdf</span>\n/<span class=\"regexp\">/= require vendor/pdf</span>.worker\n</code></pre>\n<p>Then we need to modify our view in order to incorporate the PDF instead of displaying a simple link. Which gives us this:</p>\n<pre><code class=\"undefined\">&lt;div id=\"viewer\"&gt;&lt;/div&gt;\n\n&lt;script&gt;\n\n  var url = '&lt;%= product_url(product, :format =&gt; :pdf) %&gt;';\n\n  PDFJS.workerSrc = '&lt;%= asset_path('vendor/pdf.worker.js') %&gt;';\n\n  'use strict';\n\n    function renderPage(div, pdf, pageNumber, callback) {\n      pdf.getPage(pageNumber).then(function(page) {\n        var scale = 1.5;\n        var viewport = page.getViewport(scale);\n\n        var pageDisplayWidth = viewport.width;\n        var pageDisplayHeight = viewport.height;\n\n        var pageDivHolder = document.createElement('div');\n        pageDivHolder.className = 'pdfpage';\n        pageDivHolder.style.width = pageDisplayWidth + 'px';\n        pageDivHolder.style.height = pageDisplayHeight + 'px';\n        div.appendChild(pageDivHolder);\n\n        // Prepare canvas using PDF page dimensions\n        var canvas = document.createElement('canvas');\n        var context = canvas.getContext('2d');\n        canvas.width = pageDisplayWidth;\n        canvas.height = pageDisplayHeight;\n        pageDivHolder.appendChild(canvas);\n\n        // Render PDF page into canvas context\n        var renderContext = {\n          canvasContext: context,\n          viewport: viewport\n        };\n        page.render(renderContext).promise.then(callback);\n      });\n    }\n\n    PDFJS.getDocument(url).then(function renderPdf(pdf) {\n      var viewer = document.getElementById('viewer');\n      var pageNumber = 1;\n      renderPage(viewer, pdf, pageNumber++, function pageRenderingComplete() {\n        if (pageNumber &gt; pdf.numPages) {\n          return; \n        }\n        // Continue rendering of the next page\n        renderPage(viewer, pdf, pageNumber++, pageRenderingComplete);\n      });\n    });\n\n&lt;/script&gt;\n</code></pre>\n<p>As you may have noticed in the previous piece of code, PDF.js heavily relies on the use of promises. The first one is simply that the PDF you want to display is fully downloaded by your browser, and as long as it's not the case, you'll have to wait for anything to be displayed.</p>\n<p>For instance:</p>\n<pre><code class=\"ruby\">var url = <span class=\"string\">'&lt;%= product_url(product, :format =&gt; :pdf) %&gt;'</span>;       \n<span class=\"constant\">PDFJS</span>.getDocument(url).<span class=\"keyword\">then</span>(function(pdf) {\n    <span class=\"regexp\">//</span> you can now use *pdf* here\n});\n</code></pre>\n<p>What we showed you here was just a first shot: for example, we display the pages one after the other. But as you can guess, this library can do a lot more and if you have some other needs or thoughts about this, you should certainly take a look at the <strong><a href=\"https://github.com/mozilla/pdf.js/tree/master/examples\">example repository</a></strong> of the github project, it's a real gold mine.</p>\n<h2>Additional resources</h2>\n<p>You can also find a lot more than this short introduction if you dig into:</p>\n<ul>\n<li><strong><a href=\"https://mozilla.github.io/pdf.js\">https://mozilla.github.io/pdf.js</a></strong></li>\n<li><strong><a href=\"https://github.com/mozilla/pdf.js/\">https://github.com/mozilla/pdf.js/</a></strong></li>\n</ul>\n<p><strong><!--HubSpot Call-to-Action Code --><span class=\"hs-cta-wrapper\" id=\"hs-cta-wrapper-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\"><span class=\"hs-cta-node hs-cta-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\" id=\"hs-cta-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\"><!--[if lte IE 8]><div id=\"hs-cta-ie-element\"></div><![endif]--><a href=\"https://cta-redirect.hubspot.com/cta/redirect/1684659/fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\" target=\"_blank\"><img class=\"hs-cta-img\" id=\"hs-cta-img-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2\" style=\"border-width:0px;\" src=\"https://no-cache.hubspot.com/cta/default/1684659/fb3606cc-cc1b-47d0-ae85-2c9f69837fe2.png\" alt=\"New Call-to-action\"></a></span></span><!-- end HubSpot Call-to-Action Code --></strong></p>\n<div id=\"disqus_thread\">&nbsp;</div>"
tags:
  - label: "Under the hood"
    value: "under-the-hood"

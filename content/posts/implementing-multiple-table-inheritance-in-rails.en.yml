lang: en
slug: implementing-multiple-table-inheritance-in-rails
originalPath: https://www.belighted.com/blog/implementing-multiple-table-inheritance-in-rails
title: Implementing multiple table inheritance in Rails
author: Dominique L.
description: Rails’ way of representing model inheritance in the database is
  called single table inheritance, but this technique is only appropriate in
  specific cases. Here we propose a simple implementation of an alternative
  representation called multiple table inheritance.
image: ./images/What-is-Object-Relational-Mapping-.jpg
date: 1451606400000
body: >-
  <h2>Implementing multiple table inheritance in Rails</h2>

  <p>Rails’ default —and actually only— way of representing model inheritance at the database level is called single table inheritance (STI for short). With this technique, the entire model hierarchy is stored in a single table, containing a column for every attribute that a model in the hierarchy possesses, plus an additional column to specify the actual type of the model. For example, let’s say we have the following models:</p>

  <!--more-->

  <pre><code class="ruby"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="inheritance">&lt; <span class="parent">ActiveRecord::Base</span></span></span>
    <span class="comment"># Attributes: reference, price, title</span>
    validates <span class="symbol">:reference</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>, uniqueness<span class="symbol">:</span> <span class="keyword">true</span>
    validates <span class="symbol">:title</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>
    validates <span class="symbol">:price</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>, numericality<span class="symbol">:</span> { greater_than_or_equal_to<span class="symbol">:</span> <span class="number">0</span> }
  <span class="keyword">end</span>


  <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="inheritance">&lt; <span class="parent">Product</span></span></span>
    <span class="comment"># Attributes: writer, number_of_pages</span>
    validates <span class="symbol">:writer</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>
    validates <span class="symbol">:number_of_pages</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>, numericality<span class="symbol">:</span> { only_integer<span class="symbol">:</span> <span class="keyword">true</span>, greater_than<span class="symbol">:</span> <span class="number">0</span> }

    scope <span class="symbol">:for_writer</span>, -&gt;(writer) { where(writer<span class="symbol">:</span> writer) }
  <span class="keyword">end</span>


  <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="inheritance">&lt; <span class="parent">Product</span></span></span>
    <span class="comment"># Attributes: studio, director, format</span>
    validates <span class="symbol">:studio</span>, <span class="symbol">:director</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>
    validates <span class="symbol">:format</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>, inclusion<span class="symbol">:</span> { <span class="keyword">in</span><span class="symbol">:</span> [ <span class="string">"DVD"</span>, <span class="string">"Blu-ray"</span> ] }
  <span class="keyword">end</span>

  </code></pre>

  <p><br> In the database we have a single table, <code>products</code>:</p>

  <table>

  <thead>

  <tr>

  <th align="right">id</th>

  <th align="left">type</th>

  <th align="left">reference</th>

  <th align="right">price</th>

  <th align="left">title</th>

  <th align="left">writer</th>

  <th align="right">number_of_pages</th>

  <th align="left">studio</th>

  <th align="left">director</th>

  <th>format</th>

  </tr>

  </thead>

  <tbody>

  <tr>

  <td align="right">1</td>

  <td align="left">Book</td>

  <td align="left">B-0001</td>

  <td align="right">9.99</td>

  <td align="left">The Color of Magic</td>

  <td align="left">Terry Pratchett</td>

  <td align="right">288</td>

  <td align="left"><em>NULL</em></td>

  <td align="left"><em>NULL</em></td>

  <td><em>NULL</em></td>

  </tr>

  <tr>

  <td align="right">2</td>

  <td align="left">Movie</td>

  <td align="left">M-0001</td>

  <td align="right">8.67</td>

  <td align="left">The Thing</td>

  <td align="left"><em>NULL</em></td>

  <td align="right"><em>NULL</em></td>

  <td align="left">Universal Pictures</td>

  <td align="left">John Carpenter</td>

  <td>DVD</td>

  </tr>

  <tr>

  <td align="right">3</td>

  <td align="left">Book</td>

  <td align="left">B-0002</td>

  <td align="right">6.00</td>

  <td align="left">American Gods</td>

  <td align="left">Neil Gaiman</td>

  <td align="right">624</td>

  <td align="left"><em>NULL</em></td>

  <td align="left"><em>NULL</em></td>

  <td><em>NULL</em></td>

  </tr>

  <tr>

  <td align="right">4</td>

  <td align="left">Movie</td>

  <td align="left">M-0002</td>

  <td align="right">15.95</td>

  <td align="left">Commando</td>

  <td align="left"><em>NULL</em></td>

  <td align="right"><em>NULL</em></td>

  <td align="left">20th Century Fox</td>

  <td align="left">Mark L. Lester</td>

  <td>Blu-ray</td>

  </tr>

  </tbody>

  </table>

  <p>The first thing you see is that for every row, a bunch of columns are empty. This is the major drawback of single table inheritance, and it prevents us to put a NOT NULL constraint on the columns that are not shared between models, even if these attributes are mandatory for the relevant model (and yes, you should definitely put NOT NULL constraints as well as FOREIGN KEY constraints in the database, but this is for another blog post). Furthermore, you can feel that mixing attributes that have nothing to do with each other and only make sense for a subset of rows is somewhat wrong, and the more we'll have models that inherit from <code>Product</code>, the more it will become apparent. Actually, STI is appropriate only when all the models in the hierarchy share the exact same set of attributes (i.e. all the attributes are defined on the parent model) and only differ in their behavior at the application level.</p>

  <p>What we'd like to have instead is a table for each model, and a link between a child row and a parent row. This way of representing model inheritance is called (you guessed it) multiple table inheritance.</p>

  <h3>Existing implementations</h3>

  <p>There is a gem called <a href="https://github.com/mhuggins/multiple_table_inheritance">multiple_table_inheritance</a> to achieve this but, in addition to the fact that it has not been maintained for the past 3 years, it has in my opinion a major problem: since it does not use class inheritance at all between models, you are forced to override <code>is_a?</code> in the "child" models in order to work around Rails' type checking in case of an association to the parent model (without that, inserting a <code>Book</code> instance in a <code>has_many :products</code> association would result in a <code>ActiveRecord::AssociationTypeMismatch</code> exception being raised). Fooling around with such a fundamental method can lead to unpredictable behavior and is best avoided.</p>

  <h3>Our proposed implementation of MTI in Rails</h3>

  <p>So, how can we have an MTI-like structure in the database but without straying too far away from ActiveRecord's well-known realm? The trick is actually quite simple: we continue to use the built-in STI mechanism, but we move the attributes of each child model to a companion ActiveRecord object linked to this model, and we delegate all the attribute accessors to this companion object in order to make it completely transparent for the outside world. The code looks like this:</p>

  <pre><code class="ruby"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="inheritance">&lt; <span class="parent">ActiveRecord::Base</span></span></span>
    <span class="comment"># Attributes: reference, price, title</span>
    validates <span class="symbol">:reference</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>, uniqueness<span class="symbol">:</span> <span class="keyword">true</span>
    validates <span class="symbol">:title</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>
    validates <span class="symbol">:price</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>, numericality<span class="symbol">:</span> { greater_than_or_equal_to<span class="symbol">:</span> <span class="number">0</span> }
  <span class="keyword">end</span>


  <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="inheritance">&lt; <span class="parent">Product</span></span></span>
    has_one <span class="symbol">:companion</span>, class_name<span class="symbol">:</span> <span class="string">"BookCompanion"</span>, inverse_of<span class="symbol">:</span> <span class="symbol">:book</span>, dependent<span class="symbol">:</span> <span class="symbol">:destroy</span>, autosave<span class="symbol">:</span> <span class="keyword">true</span>

    delegate <span class="symbol">:writer</span>, <span class="symbol">:number_of_pages</span>, <span class="symbol">:writer</span>=, <span class="symbol">:number_of_pages</span>=, to<span class="symbol">:</span> <span class="symbol">:lazily_built_companion</span>

    validates <span class="symbol">:writer</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>
    validates <span class="symbol">:number_of_pages</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>, numericality<span class="symbol">:</span> { only_integer<span class="symbol">:</span> <span class="keyword">true</span>, greater_than<span class="symbol">:</span> <span class="number">0</span> }

    scope <span class="symbol">:for_writer</span>, -&gt;(writer) { joins(<span class="symbol">:companion</span>).merge(<span class="constant">BookCompanion</span>.for_writer(writer)) }

    private
    <span class="function"><span class="keyword">def</span> <span class="title">lazily_built_companion</span></span>
      companion || build_companion
    <span class="keyword">end</span>
  <span class="keyword">end</span>


  <span class="class"><span class="keyword">class</span> <span class="title">BookCompanion</span> <span class="inheritance">&lt; <span class="parent">ActiveRecord::Base</span></span></span>
    <span class="comment"># Attributes: writer, number_of_pages</span>

    belongs_to <span class="symbol">:book</span>, inverse_of<span class="symbol">:</span> <span class="symbol">:companion</span>

    validates <span class="symbol">:book</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>

    scope <span class="symbol">:for_writer</span>, -&gt;(writer) { where(writer<span class="symbol">:</span> writer) }
  <span class="keyword">end</span>


  <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="inheritance">&lt; <span class="parent">Product</span></span></span>
    has_one <span class="symbol">:companion</span>, class_name<span class="symbol">:</span> <span class="string">"MovieCompanion"</span>, inverse_of<span class="symbol">:</span> <span class="symbol">:movie</span>, dependent<span class="symbol">:</span> <span class="symbol">:destroy</span>, autosave<span class="symbol">:</span> <span class="keyword">true</span>

    delegate <span class="symbol">:studio</span>, <span class="symbol">:director</span>, <span class="symbol">:format</span>, <span class="symbol">:studio</span>=, <span class="symbol">:director</span>=, <span class="symbol">:format</span>=, to<span class="symbol">:</span> <span class="symbol">:lazily_built_companion</span>

    validates <span class="symbol">:studio</span>, <span class="symbol">:director</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>
    validates <span class="symbol">:format</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>, inclusion<span class="symbol">:</span> { <span class="keyword">in</span><span class="symbol">:</span> [ <span class="string">"DVD"</span>, <span class="string">"Blu-ray"</span> ] }

    private
    <span class="function"><span class="keyword">def</span> <span class="title">lazily_built_companion</span></span>
      companion || build_companion
    <span class="keyword">end</span>
  <span class="keyword">end</span>


  <span class="class"><span class="keyword">class</span> <span class="title">MovieCompanion</span> <span class="inheritance">&lt; <span class="parent">ActiveRecord::Base</span></span></span>
    <span class="comment"># Attributes: studio, director, format</span>

    belongs_to <span class="symbol">:movie</span>, inverse_of<span class="symbol">:</span> <span class="symbol">:companion</span>

    validates <span class="symbol">:movie</span>, presence<span class="symbol">:</span> <span class="keyword">true</span>
  <span class="keyword">end</span>

  </code></pre>

  <p><br> In the database we now have three tables, <code>products</code>, <code>book_companions</code> and <code>movie_companions</code>, respectively:</p>

  <table>

  <thead>

  <tr>

  <th align="right">id</th>

  <th align="left">type</th>

  <th align="left">reference</th>

  <th align="right">price</th>

  <th align="left">title</th>

  </tr>

  </thead>

  <tbody>

  <tr>

  <td align="right">1</td>

  <td align="left">Book</td>

  <td align="left">B-0001</td>

  <td align="right">9.99</td>

  <td align="left">The Color of Magic</td>

  </tr>

  <tr>

  <td align="right">2</td>

  <td align="left">Movie</td>

  <td align="left">M-0001</td>

  <td align="right">8.67</td>

  <td align="left">The Thing</td>

  </tr>

  <tr>

  <td align="right">3</td>

  <td align="left">Book</td>

  <td align="left">B-0002</td>

  <td align="right">6.00</td>

  <td align="left">American Gods</td>

  </tr>

  <tr>

  <td align="right">4</td>

  <td align="left">Movie</td>

  <td align="left">M-0002</td>

  <td align="right">15.95</td>

  <td align="left">Commando</td>

  </tr>

  </tbody>

  </table>

  <table>

  <thead>

  <tr>

  <th align="right">id</th>

  <th align="right">book_id</th>

  <th align="left">writer</th>

  <th align="right">number_of_pages</th>

  </tr>

  </thead>

  <tbody>

  <tr>

  <td align="right">1</td>

  <td align="right">1</td>

  <td align="left">Terry Pratchett</td>

  <td align="right">288</td>

  </tr>

  <tr>

  <td align="right">2</td>

  <td align="right">3</td>

  <td align="left">Neil Gaiman</td>

  <td align="right">624</td>

  </tr>

  </tbody>

  </table>

  <table>

  <thead>

  <tr>

  <th align="right">id</th>

  <th align="right">movie_id</th>

  <th align="left">studio</th>

  <th align="left">director</th>

  <th>format</th>

  </tr>

  </thead>

  <tbody>

  <tr>

  <td align="right">1</td>

  <td align="right">2</td>

  <td align="left">Universal Pictures</td>

  <td align="left">John Carpenter</td>

  <td>DVD</td>

  </tr>

  <tr>

  <td align="right">2</td>

  <td align="right">4</td>

  <td align="left">20th Century Fox</td>

  <td align="left">Mark L. Lester</td>

  <td>Blu-ray</td>

  </tr>

  </tbody>

  </table>

  <p>No more mixed attributes, no more empty columns. Yeah!</p>

  <p>And in the console, you can check that it works really smoothly:</p>

  <pre><code class="undefined">irb(main):001:0&gt; Book.create!(reference: "B-0001", price: 9.99, title: "The Color of Magic", number_of_pages: 288)

  ActiveRecord::RecordInvalid: Validation failed: Writer can't be blank

  irb(main):002:0&gt; Book.create!(reference: "B-0001", price: 9.99, title: "The Color of Magic", writer: "Terry Pratchett", number_of_pages: 288)

  =&gt; #&lt;Book id: 1, type: "Book", reference: "B-0001", price: #&lt;BigDecimal:7fb35cbe3680,'0.999E1',18(36)&gt;, title: "The Color of Magic", created_at: "2015-12-30 12:47:41", updated_at: "2015-12-30 12:47:41"&gt;

  irb(main):003:0&gt; Movie.create!(reference: "M-0001", price: 8.67, title: "The Thing", studio: "Universal Pictures", director: "John Carpenter", format: "DVD")

  =&gt; #&lt;Movie id: 2, type: "Movie", reference: "M-0001", price: #&lt;BigDecimal:7fb35e262258,'0.867E1',18(36)&gt;, title: "The Thing", created_at: "2015-12-30 12:47:52", updated_at: "2015-12-30 12:47:52"&gt;

  irb(main):004:0&gt; Product.find(1).class.name

  =&gt; "Book"

  irb(main):005:0&gt; Product.find(1).number_of_pages

  =&gt; 288

  irb(main):006:0&gt; Product.find(2).class.name

  =&gt; "Movie"

  irb(main):007:0&gt; Product.find(2).director

  =&gt; "John Carpenter"

  irb(main):008:0&gt; Book.for_writer("Terry Pratchett").count

  =&gt; 1

  </code></pre>

  <p><br> As you can see, from the external code point of view, it is as if these companion objects didn't exist at all.</p>

  <h2>Some notes on the above implementation</h2>

  <ul>

  <li>As Rails validations use the attribute readers (rather than the instance variables), we can keep them in the main class. In addition to simplify the implementation (we don't have to deal with validation errors coming from the companion object), this totally makes sense because the companion object is a mere technicality and not a real business object. After all, what we want to ensure is that a Book has a writer, wherever this writer attribute is actually stored.</li>

  <li>The delegation is not done directly to the <code>companion</code> association, but to the <code>lazily_built_companion</code> method instead. This is to ensure that we always have a companion instance, even when working with a new object.</li>

  <li>It is important not to forget the <code>autosave: true</code> option in the <code>has_one :companion</code> association definition, or else the companion object will only be saved at creation but not on subsequent updates.</li>

  <li>As you can see in the <code>Book</code> class, you can use the <code>merge</code> method of <code>ActiveRecord::Relation</code> to elegantly define scopes that use the attributes defined on the companion class.</li>

  <li>

  <p>To be complete, we should also override the <code>changed_attributes</code> method (and possibly some others) from the <code>ActiveSupport::Dirty</code> module in the child classes, something along the lines of:</p>

  <pre><code class="ruby"><span class="function"><span class="keyword">def</span> <span class="title">changed_attributes</span></span>
    <span class="keyword">super</span>.merge(lazily_built_companion.changed_attributes)
  <span class="keyword">end</span>

  </code></pre>

  </li>

  <li>

  <p>I'm pretty sure that with a bit of meta-programming, all this can quite easily be extracted in a module to remove all the boilerplate from the classes and DRYify the code. This exercise will be left to the reader ;-)</p>

  </li>

  </ul>

  <br><!--HubSpot Call-to-Action Code --><span class="hs-cta-wrapper" id="hs-cta-wrapper-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2"><span class="hs-cta-node hs-cta-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2" id="hs-cta-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2"><!--[if lte IE 8]><div id="hs-cta-ie-element"></div><![endif]--><a href="https://cta-redirect.hubspot.com/cta/redirect/1684659/fb3606cc-cc1b-47d0-ae85-2c9f69837fe2" target="_blank"><img class="hs-cta-img" id="hs-cta-img-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2" style="border-width:0px;" src="https://no-cache.hubspot.com/cta/default/1684659/fb3606cc-cc1b-47d0-ae85-2c9f69837fe2.png" alt="New Call-to-action"></a></span></span><!-- end HubSpot Call-to-Action Code -->
tags:
  - label: Under the hood
    value: under-the-hood

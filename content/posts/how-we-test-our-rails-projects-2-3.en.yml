lang: en
slug: how-we-test-our-rails-projects-2-3
originalPath: https://www.belighted.com/blog/how-we-test-our-rails-projects-2-3
title: How we test our Rails projects (2/3)
author: Philippe V.
description: >
  Second of a series of 3 articles about how we write automatic tests for our
  rails projects.

  This article focuses on the supporting code we wrote.
image: images/default_blogpost_image_7@1x.jpg
date: 1451606400000
body: >-
  <h2>Introduction</h2>

  <p>This blog post is the second of a series of 3 articles explaining how we write automatic tests for our Rails projects.</p>

  <!--more-->

  <p>The 3 parts discuss the following topics :</p>

  <ul>

  <li><strong><a href="https://belighted.com/blog/how-we-test-our-rails-projects-1-3">Part 1 : The tools. This part will present the third party tools we use and what are their purpose in our stack</a>.</strong></li>

  <li>Part 2 : The structure. This part will present the file structure we use to organize the tests and the code related to them.</li>

  <li><strong><a href="https://belighted.com/blog/how-we-test-our-rails-projects-3-3">Part 3 : The flow. This part will explain what kind of test we write, when we write them and how we go from the test to the code backand forth.</a></strong></li>

  </ul>

  <h2>Part 2 : The structure</h2>

  <h3>/spec</h3>

  <p>Since we are using RSpec, we won't be using the <code>test</code> folder but the <code>spec</code> one.</p>

  <p>This folder will keep all our example files (an example is any kind of automatic test in RSpec terms), but also code and assets specific to our tests. More precisely there will be 3 subfolders dedicated to store files helping our examples and as many folders storing example files.</p>

  <p>The 3 sub folders containing helping files are :</p>

  <ul>

  <li><code>factories</code> : Where we put <code>FactoryGirl</code> factory definitions. Usually one file by object tree we need to build.</li>

  <li><code>resources</code> : Where we put static files we need in our examples. Those can be files we need to simulate an upload, files we need to compare with the result of a file generation, picture files we need to populate avatars of our users, etc. When we need a file to be used as-is without the need of parsing it, we will put it there.</li>

  <li><code>support</code> : Where we put all the supporting code for our test environment. This is the biggest one of the three and has its own sub structure.</li>

  </ul>

  <p>The other subdirectories will <em>mostly</em> mimic the structure of your <code>app</code> folder. We usually follow a structure of <em>stereotyped folders</em> ( the rails way ) for the common code and <a href="https://belighted.com/blog/organize-rails-files-by-topic"><em>topic folders</em></a> for specific code. Thus if we have the subfolders <code>app/models/user.rb</code>, <code>app/api_clients/twilio_client.rb</code>, and <code>app/invoicing/invoice.rb</code> files, we will have the <code>spec/models/user_spec.rb</code>, <code>spec/api_clients/twilio_client_spec.rb</code> and <code>spec/invoicing/invoice_spec.rb</code>.</p>

  <p>I said <em>mostly</em> because there is one additional folder in <code>spec</code> which does not appear in the <code>app</code> folder : the <code>features</code> folder.</p>

  <h3>/spec/features</h3>

  <p>This folder is where we put our <a href="https://paulmarin.net/wp-content/uploads/2015/12/you-dont-say.jpg">feature specs</a>.</p>

  <p>We have tried using special tools like <a href="https://cucumber.io/">Cucumber</a> for our feature specs. It turns out for us that the cost of an additional tool and an additional language is not worth the effort. Especially since, <em>in our usual projects</em>, the product owner almost never read the user stories, even less writes them; the project manager is responsible for translating the needs to the developer and the developer writes and maintains the stories. Therefore we wanted a tool making the task easy for the developer and the combination of RSpec, SitePrism and Capybara is the best we have found to enable the developers to feel at home.</p>

  <p>This folder hosts the feature specs but what does our feature specs looks like ?</p>

  <p>Our files (code and specs) are always structured to hoist the important parts at the top of the file and the boilerplate at the bottom. For our feature specs this means that the file has a short name matching its file name allowing us to easily jump on them in our editor, then has a longer description in the form of a user story, then the code really begins.</p>

  <p>The code starts with the inclusion of the required shared_contexts for setting up a coarse grained state of the app, then a background block calling some private methods for a more fine grained initial setup.</p>

  <p>Then we have the scenarios. Each scenario has a short descriptive name allowing us to differentiate it from the other scenarios of the same feature (meaning a feature file with a single scenario can have a very simple name). The scenario starts by calling some private methods to put the application in the exact state required for that scenario. Then we have a succession of private method calls written to look like sentences. Active first person sentences are used to describe how the user interacts with the application. Passive sentences are used to describe assertions made in order to continue or fail the examples. Other active sentences are used to describe external actions happening.</p>

  <p>This technique is very simple and gets almost all the benefits from tools like cucumber without the hassle of them. As developers we are not at all disturbed by the snake case transformation of the sentences and the 3 simple gramatical rules enable us to immediately know what kind of <em>step</em> we are in.</p>

  <p>After the scenarios we enter the <code>private</code> area where we can have test values in the form of <code>let()</code> calls and the definition of all the private methods we have called earlier.</p>

  <p>Here is an example illustrating all these concepts :</p>

  <p>We imagine a story where a new client must have its ticket payment validated before downloading its concert ticket.</p>

  <pre><code class="ruby"><span class="comment"># /spec/features/fresh_client_want_to_download_</span>

  <span class="keyword">require</span> <span class="string">'rails_helper'</span>


  <span class="constant">RSpec</span>.feature <span class="string">'a user who has bought ticket using bank transfer want to download its ticket'</span>, <span class="string">'
    As a User having bought concert tickets using bank transfer
    In order to be able to enter in the concert room
    I want to download my tickets
  '</span> <span class="keyword">do</span>

    include_context <span class="string">'users exist'</span>
    include_context <span class="string">'concert exist'</span>
    include_context(<span class="string">'a ticket has been bought using bank transfer'</span>) <span class="keyword">do</span>
      let(<span class="symbol">:ticket_concert</span>){ concert }
      let(<span class="symbol">:ticket_buyer</span>){ client }
    <span class="keyword">end</span>

    background <span class="keyword">do</span>
      free_some_seats_for_the_concert
    <span class="keyword">end</span>

    scenario <span class="string">'I can download my tickets after an admin validation'</span>, <span class="symbol">:js</span>  <span class="keyword">do</span>

      as(client) <span class="keyword">do</span>
        i_go_to_my_dashboard
        i_go_to_the_details_of_my_account
        my_ticket_is_not_available_until_my_payment_has_been_validated
      <span class="keyword">end</span>

      as(admin) <span class="keyword">do</span>
        i_go_to_the_admin_panel
        i_display_the_first_pending_payment
        i_validate_the_bank_transfer_payment
      <span class="keyword">end</span>

      as(client) <span class="keyword">do</span>
        i_follow_the_email_annoucing_me_my_ticket_is_available
        i_download_my_ticket
      <span class="keyword">end</span>

      one_less_seat_is_available_for_the_concert

    <span class="keyword">end</span>

    private
    ...
  <span class="keyword">end</span>

  </code></pre>

  <p>As you can see, the scenario is quite easy to follow and when we read a sentence we can immediately know if it is a user action step ( <code>i_go_to_my_dashboard</code> ), an assertion step (<code>my_ticket_is_not_available_until_my_payment_has_been_validated</code>) or an external action step ( <code>free_some_seats_for_the_concert</code> ).</p>

  <p>The question you are probably asking yourself is : "But where is the code ?". The code appears after the <code>private</code> keyword. we have a list of <code>let()</code> statement for when a value needs to be used in multiple steps but we don't really care about what it is ( <code>let(:street_name){ 'Boulevard Acme' }</code>), and a lot of very small private methods translating those steps into method calls like these :</p>

  <pre><code class="ruby"><span class="function"><span class="keyword">def</span> <span class="title">i_go_to_my_dashboard</span></span>
    navbar.visit_dashboard
  <span class="keyword">end</span>


  <span class="function"><span class="keyword">def</span> <span class="title">i_follow_the_email_annoucing_me_my_ticket_is_available</span></span>
    last_email = mailbox_for(client.email).last
    expect(last_email.subject).to eq <span class="constant">I18n</span>.t(<span class="string">"ticket_mailer.available_ticket.subject"</span>)
    click_email_link_matching(%r<span class="string">'my/tickets'</span>, last_email)
  <span class="keyword">end</span>

  </code></pre>

  <p>Ok but where do those <code>as()</code>, <code>navbar</code>, <code>client</code>, ... methods come from ? You haven't told us everything !</p>

  <p>Not yet, but here come the best part ...</p>

  <h3>/spec/support</h3>

  <p>This folder contains all the supporting code for our examples, it will enable us to :</p>

  <ul>

  <li>Setup very easily the application in a complex state thanks to shared_contexts.</li>

  <li>Extend the Rspec DSL with some useful new keywords thanks to helpers (use them with caution).</li>

  <li>Override some behaviour in order to better isolate some components when we want to test them in isolation (testing a <code>User</code> record should require ActiveRecord, fair enough but not the complete Rails app juste because of Devise).</li>

  <li>Share page manipulation logic between multiple scenarios thanks to SitePrism page objects.</li>

  </ul>

  <h4>/spec/support/initializers</h4>

  <p>The first support subfolder we are going to create is <code>/spec/support/initializers</code>. The purpose of this folder is to mimic <code>/config/initializers</code> in the sense that all of its files will be loaded during the <em>boot</em> process of our app. Usually one puts RSpec configuration in <code>/spec/spec_helper.rb</code> and Rails specific RSpec configuration in <code>/spec/rails_helper.rb</code>. We do put RSpec configuration in <code>/spec/spec_helper.rb</code> but we split <code>/spec/spec_helper.rb</code> config in multiple files stored in <code>/spec/support/initializers</code> folder. This allows us to keep <code>/spec/rails_helper.rb</code> smaller, to have topic config files and to have other spec helper files loading only a subset of the initializers (typically we have an <code>/spec/activerecord_spec_helper</code> loading only what is required to test activerecord objects).</p>

  <p>Here is what a fresh project starts with most of the time :</p>

  <p><code>capybara.rb</code> : setup capybara and its drivers. We mostly uses poltergeist and rack-test drivers. we configure autoscreenshot upon failure and check ENV variables or metadate for diver overrides.</p>

  <pre><code class="ruby"><span class="comment">#/spec/support/initializers/capybara.rb</span>


  <span class="keyword">require</span> <span class="string">'launchy'</span>

  <span class="keyword">require</span> <span class="string">'capybara'</span>

  <span class="keyword">require</span> <span class="string">'capybara/poltergeist'</span>

  <span class="keyword">require</span> <span class="string">'capybara/rails'</span>

  <span class="keyword">require</span> <span class="string">'capybara/rspec'</span>

  <span class="keyword">require</span> <span class="string">'selenium-webdriver'</span>

  <span class="keyword">require</span> <span class="string">'capybara-screenshot'</span>

  <span class="keyword">require</span> <span class="string">'capybara-screenshot/rspec'</span>


  <span class="constant">Capybara</span>.register_driver <span class="symbol">:poltergeist</span> <span class="keyword">do</span> |app|
    <span class="constant">Capybara::Poltergeist::Driver</span>.new(
        app,
        js_errors<span class="symbol">:</span> <span class="keyword">true</span>, <span class="comment"># break on js error</span>
        timeout<span class="symbol">:</span> <span class="number">180</span>, <span class="comment"># maximum time in second for the server to produce a response</span>
        debug<span class="symbol">:</span> <span class="keyword">false</span>, <span class="comment"># more verbose log</span>
        window_size<span class="symbol">:</span> [<span class="number">1280</span>, <span class="number">800</span>], <span class="comment"># not responsive, used to simulate scroll when needed</span>
        inspector<span class="symbol">:</span> <span class="keyword">false</span>, <span class="comment"># use debug breakpoint and chrome inspector</span>
        phantomjs_options<span class="symbol">:</span> [<span class="string">'--ignore-ssl-errors=yes'</span>] ,
        <span class="comment"># extensions: [Rails.root.join('spec', 'support', 'phantomjs_ext', 'geolocation.js').expand_path.to_s]</span>
    )
  <span class="keyword">end</span>



  <span class="constant">Capybara</span>.register_driver <span class="symbol">:chrome</span> <span class="keyword">do</span> |app|
    <span class="constant">Capybara::Selenium::Driver</span>.new(app, <span class="symbol">:browser</span> =&gt; <span class="symbol">:chrome</span>)
  <span class="keyword">end</span>



  <span class="constant">Capybara</span>.register_driver <span class="symbol">:firefox</span> <span class="keyword">do</span> |app|
    <span class="constant">Capybara::Selenium::Driver</span>.new(app, <span class="symbol">:browser</span> =&gt; <span class="symbol">:firefox</span>)
  <span class="keyword">end</span>



  <span class="constant">Capybara</span>.javascript_driver = <span class="constant">ENV</span>.fetch(<span class="string">'DRIVER'</span>) { <span class="string">'poltergeist'</span> }.to_sym

  <span class="constant">Capybara</span>.asset_host = <span class="string">'https://localhost:3000'</span> <span class="comment"># enable asset in save_and_open_page if we have a dev server running</span>



  <span class="constant">Capybara</span>.configure <span class="keyword">do</span> |config|
    config.default_selector = <span class="symbol">:css</span>
    config.default_max_wait_time= <span class="number">2</span>
    config.match = <span class="symbol">:prefer_exact</span>
    config.ignore_hidden_elements = <span class="keyword">true</span>
  <span class="keyword">end</span>


  [<span class="symbol">:chrome</span>, <span class="symbol">:firefox</span>, <span class="symbol">:poltergeist</span>].each <span class="keyword">do</span> |driver|
    <span class="constant">RSpec</span>.configure <span class="keyword">do</span> |config|
      config.around(<span class="symbol">:each</span>, driver) <span class="keyword">do</span> |example|
        current_javascript_driver = <span class="constant">Capybara</span>.javascript_driver
        current_default_driver = <span class="constant">Capybara</span>.default_driver
        <span class="constant">Capybara</span>.javascript_driver = driver
        <span class="constant">Capybara</span>.default_driver = driver
        example.run
        <span class="constant">Capybara</span>.javascript_driver = current_javascript_driver
        <span class="constant">Capybara</span>.default_driver = current_default_driver
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>



  <span class="constant">Capybara</span>.save_and_open_page_path = <span class="constant">Rails</span>.root.join(<span class="string">'tmp'</span>, <span class="string">'save_and_open_page'</span>)

  <span class="constant">Capybara::Screenshot</span>.prune_strategy = { keep<span class="symbol">:</span> <span class="number">10</span> }


  <span class="constant">Capybara::Screenshot</span>.register_driver(<span class="symbol">:chrome</span>) <span class="keyword">do</span> |driver, path|
    driver.browser.save_screenshot path
  <span class="keyword">end</span>

  </code></pre>

  <p><code>database_cleaner.rb</code> : We configure database cleaner in a very simple fashion in order to either use transaction strategy during activerecord and simple feature specs , or truncation during javascripted feature specs. This file is really project dependent and this example is a simple one. Usually we add here seed management: data coming from the seed are loaded once at the beginning and excluded from the cleaning process.</p>

  <pre><code class="ruby"><span class="comment">#/spec/support/initializers/database_cleaner.rb</span>


  <span class="keyword">require</span> <span class="string">'database_cleaner'</span>


  <span class="constant">RSpec</span>.configure <span class="keyword">do</span> |config|

    config.before(<span class="symbol">:suite</span>) <span class="keyword">do</span>
      <span class="constant">DatabaseCleaner</span>.strategy = <span class="symbol">:transaction</span>
      <span class="constant">DatabaseCleaner</span>.clean_with <span class="symbol">:truncation</span>
    <span class="keyword">end</span>


    config.before(<span class="symbol">:each</span>, type<span class="symbol">:</span> <span class="symbol">:feature</span>) <span class="keyword">do</span>

      driver_shares_db_connection_with_specs = <span class="constant">Capybara</span>.current_driver == <span class="symbol">:rack_test</span>

      <span class="keyword">if</span> driver_shares_db_connection_with_specs
        <span class="constant">DatabaseCleaner</span>.strategy = <span class="symbol">:transaction</span>
      <span class="keyword">else</span>
        <span class="constant">DatabaseCleaner</span>.strategy = <span class="symbol">:truncation</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    config.before(<span class="symbol">:each</span>) <span class="keyword">do</span>
      <span class="constant">DatabaseCleaner</span>.start
    <span class="keyword">end</span>

    config.append_after(<span class="symbol">:each</span>) <span class="keyword">do</span>
      <span class="constant">DatabaseCleaner</span>.clean
    <span class="keyword">end</span>

  <span class="keyword">end</span>

  </code></pre>

  <p><code>factory_girl.rb</code> : We add a very small patch to factory girl allowing us to use file from the <code>spec/resources</code> folder. We use this in combination with <a href="https://github.com/carrierwaveuploader/carrierwave">Carrierwave</a> uploaders.</p>

  <pre><code class="ruby"><span class="comment">#/spec/support/initializers/factory_girl.rb</span>

  <span class="keyword">require</span> <span class="string">'factory_girl'</span>


  <span class="class"><span class="keyword">module</span> <span class="title">FactoryGirl::SyntaxSugar</span></span>

    <span class="function"><span class="keyword">def</span> <span class="title">resources_path</span><span class="params">(*parts)</span></span>
      <span class="constant">Pathname</span>(<span class="constant">File</span>.join(<span class="constant">File</span>.realpath(__FILE_<span class="number">_</span>), <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'resources'</span>, *parts)).expand_path
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">resources_file</span><span class="params">(*parts)</span></span>
      <span class="constant">File</span>.new resources_path(*parts)
    <span class="keyword">end</span>

  <span class="keyword">end</span>

  <span class="constant">FactoryGirl::SyntaxRunner</span>.<span class="keyword">include</span> <span class="constant">FactoryGirl::SyntaxSugar</span>


  <span class="constant">RSpec</span>.configure <span class="keyword">do</span> |config|
    config.<span class="keyword">include</span> <span class="constant">FactoryGirl::Syntax::Methods</span>
    config.<span class="keyword">include</span> <span class="constant">FactoryGirl::SyntaxSugar</span>

    config.before(<span class="symbol">:suite</span>) <span class="keyword">do</span>
      <span class="constant">FactoryGirl</span>.factories.clear
      <span class="constant">FactoryGirl</span>.sequences.clear
      <span class="constant">FactoryGirl</span>.find_definitions
    <span class="keyword">end</span>

  <span class="keyword">end</span>

  </code></pre>

  <p><code>site_prism.rb</code> : We add a patch to site prism allowing us to locate elements based on the data attribute <code>data-purpose</code>. This allows our team to work effectively between front and back developers. The backend developer must not rely on anything else than this attribute to locate an element. The front developer can change anything on the page but those attributes. It also enables us very effectively to not rely on - translateable - texts on the page.</p>

  <pre><code class="ruby"><span class="comment">#/spec/support/initializers/site_prism.rb</span>

  <span class="keyword">require</span> <span class="string">'site_prism'</span>


  <span class="constant">SitePrism</span>.configure <span class="keyword">do</span> |config|
    config.use_implicit_waits = <span class="keyword">true</span>
  <span class="keyword">end</span>


  <span class="class"><span class="keyword">module</span>  <span class="title">SitePrismExtension</span></span>

    <span class="function"><span class="keyword">def</span> <span class="title">purpose_element</span><span class="params">(purpose, **options)</span></span>
      element purpose, %<span class="constant">Q</span><span class="string">'[data-purpose="<span class="subst">#{purpose}</span>"]'</span>, **options
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">purpose_elements</span><span class="params">(purpose, elements_name=purpose.to_s.pluralize)</span></span>
      elements elements_name, %<span class="constant">Q</span><span class="string">'[data-purpose="<span class="subst">#{purpose}</span>"]'</span>
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">purpose_section</span><span class="params">(purpose, section_class)</span></span>
      section purpose, section_class, %<span class="constant">Q</span><span class="string">'[data-purpose="<span class="subst">#{purpose}</span>"]'</span>
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">purpose_sections</span><span class="params">(purpose, section_class, elements_name=purpose.to_s.pluralize)</span></span>
      sections elements_name, section_class, %<span class="constant">Q</span><span class="string">'[data-purpose="<span class="subst">#{purpose}</span>"]'</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>


  <span class="constant">SitePrism::Page</span>.send <span class="symbol">:extend</span>, <span class="constant">SitePrismExtension</span>

  <span class="constant">SitePrism::Section</span>.send <span class="symbol">:extend</span>, <span class="constant">SitePrismExtension</span>

  </code></pre>

  <p>then we can add the following line in <code>spec/rails_helper.rb</code></p>

  <pre><code class="ruby"><span class="constant">Dir</span>[<span class="constant">Rails</span>.root.join(<span class="string">'spec/support/initializers/*.rb'</span>)].each { |f| <span class="keyword">require</span> f }

  </code></pre>

  <h4>/spec/support/helpers</h4>

  <p>In an Object Oriented world, a function is something quite uncommon. Very often they are a bad idea, especially <em>helper</em> functions. This folder will nonetheless expose some of those functions. They won't be real functions but mostly extensions to objects already injected in some contexts.</p>

  <p>We usually use the following helpers :</p>

  <p><code>capybara_helpers.rb</code> : mostly acronyms because we are lazy and some method are way too long to be written when debugging. Also some component manipulation logic, in this example methods to use jquery-datetimepicker and select2 but you should change it to what you need.</p>

  <pre><code class="ruby"><span class="comment">#/spec/support/helpers/capybara_helpers.rb</span>


  <span class="keyword">require</span> <span class="string">'site_prism'</span>

  <span class="keyword">require</span> <span class="string">'capybara/rails'</span>

  <span class="keyword">require</span> <span class="string">'capybara/poltergeist'</span>


  <span class="class"><span class="keyword">module</span> <span class="title">Capybara::AliasHelper</span></span>

    <span class="function"><span class="keyword">def</span> <span class="title">snap</span></span>
      screenshot_and_open_image
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">saop</span></span>
      save_and_open_page
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">resources_path</span><span class="params">(*parts)</span></span>
      <span class="constant">Pathname</span>(<span class="constant">File</span>.join(<span class="constant">File</span>.realpath(__FILE_<span class="number">_</span>), <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'resources'</span>, *parts)).expand_path
    <span class="keyword">end</span>

  <span class="keyword">end</span>


  <span class="class"><span class="keyword">module</span>  <span class="title">Capybara::ComplexInputsHelpers</span></span>

    <span class="function"><span class="keyword">def</span> <span class="title">pick_date</span><span class="params">(value, element)</span></span>
      element.set(value.to_s)
      <span class="keyword">if</span> <span class="constant">Capybara</span>.current_driver != <span class="symbol">:rack_test</span> &amp;&amp; element[<span class="string">'id'</span>].present?
        execute_script(%<span class="constant">Q</span>|<span class="variable">$(</span><span class="string">'#<span class="subst">#{element[<span class="string">'id'</span>]}</span>'</span>).datetimepicker(<span class="string">'hide'</span>)|)
        sleep(<span class="number">0</span>.<span class="number">2</span>)
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">select_from_select2</span><span class="params">(value, select_container)</span></span>
      select_container.find(<span class="string">".select2-selection"</span>).click <span class="comment"># display filter</span>
      find(<span class="string">".select2-search__field"</span>).set(value) <span class="comment"># type text in filter</span>
      find(<span class="string">"li.select2-results__option--highlighted"</span>).click <span class="comment"># choose option</span>
      element_does_not_exist?(<span class="string">"li.select2-results__option--highlighted"</span>)
    <span class="keyword">end</span>
  <span class="keyword">end</span>


  <span class="constant">RSpec</span>.configure { |c| c.<span class="keyword">include</span> <span class="constant">Capybara::AliasHelper</span> }

  <span class="constant">RSpec</span>.configure { |c| c.<span class="keyword">include</span> <span class="constant">Capybara::ComplexInputsHelpers</span> }


  <span class="constant">SitePrism::Page</span>.send <span class="symbol">:include</span>, <span class="constant">Capybara::AliasHelper</span>

  <span class="constant">SitePrism::Page</span>.send <span class="symbol">:include</span>, <span class="constant">Capybara::ComplexInputsHelpers</span>

  <span class="constant">SitePrism::Section</span>.send <span class="symbol">:include</span>, <span class="constant">Capybara::AliasHelper</span>

  <span class="constant">SitePrism::Section</span>.send <span class="symbol">:include</span>, <span class="constant">Capybara::ComplexInputsHelpers</span>

  </code></pre>

  <p><code>page_objects_helper.rb</code>: As explained in the previous article, we use SitePrism to write page objects. Those page objects are stateless and therefore a feature spec shouldn't care about their instantiation. We use this file to expose each page object through its own private method and use memoization to be gain a small performance optimization.</p>

  <p>We use the Memoist gem to do the job , not because we are too lazy to do the code by ourselve but because we like the idea of separated responsibility and memoization is a performance responsibility different than the business logic it applies to. So we think using the <code>memoize</code> macro describe better our intent than doing the memoization by hand.</p>

  <pre><code class="ruby"><span class="comment">#/spec/support/helpers/page_objects_helper.rb</span>

  <span class="class"><span class="keyword">module</span> <span class="title">PageObjectsHelper</span></span>
    extend <span class="constant">Memoist</span>

    <span class="function"><span class="keyword">def</span> <span class="title"><span class="keyword">self</span></span>.<span class="title">page_object</span><span class="params">(helper_method, page_class)</span></span>
      define_method(helper_method) <span class="keyword">do</span>
        page_class.new
      <span class="keyword">end</span>
      memoize helper_method
    <span class="keyword">end</span>

    page_object <span class="symbol">:navbar</span>, <span class="constant">Spec::Pages::Navbar</span>
    page_object <span class="symbol">:home_page</span>, <span class="constant">Spec::Pages::HomePage</span>
    page_object <span class="symbol">:login_page</span>, <span class="constant">Spec::Pages::LoginPage</span>
    <span class="comment"># And so on ...</span>
  <span class="keyword">end</span>



  <span class="constant">RSpec</span>.configure { |c| c.<span class="keyword">include</span> <span class="constant">PageObjectsHelper</span>, type<span class="symbol">:</span> <span class="symbol">:feature</span> }

  </code></pre>

  <p><code>usual_steps_helper.rb</code> : the magic <code>as()</code> helper. The code might need change in your project but it's almost certain that you have scenario requiring someone to be logged in - or multiple persons. The point here is to separate everyone in its own session and leveraging the login_page login to do the authentication.</p>

  <p>If you have blank screenshots when using this snippet, ensure you use a version of capybara-screenshot including this fix : https://github.com/mattheworiordan/capybara-screenshot/pull/132</p>

  <pre><code class="ruby"><span class="comment">#/spec/support/helpers/usual_steps_helper.rb</span>


  <span class="class"><span class="keyword">module</span> <span class="title">UsualStepsHelper</span></span>

    <span class="function"><span class="keyword">def</span> <span class="title">as</span><span class="params">(user, options={})</span></span>
      experimental = options[<span class="symbol">:experimental</span>] || <span class="keyword">false</span>
      session_name = <span class="string">"capybara_session_for_<span class="subst">#{user.to_param}</span>"</span>
      using_session(session_name) <span class="keyword">do</span>
        visit new_user_session_path
        login_page.login user.email, user.password
        force_experimental_cookie <span class="keyword">if</span> experimental
        <span class="keyword">yield</span>
        navbar.logout
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">as_guest</span></span>
      session_name = <span class="string">"capybara_session_for_guest-<span class="subst">#{rand(<span class="number">1_000_000</span>)}</span>"</span>
      using_session(session_name) <span class="keyword">do</span>
        visit <span class="string">'/'</span>
        <span class="keyword">yield</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>

  <span class="keyword">end</span>


  <span class="constant">RSpec</span>.configure { |c| c.<span class="keyword">include</span> <span class="constant">UsualStepsHelper</span>, type<span class="symbol">:</span> <span class="symbol">:feature</span> }

  </code></pre>

  <h4>/spec/support/overrides</h4>

  <p>The last folder contains the most problematic kind of code, patches. When writing tests, you typically want to assert how your code is behaving. Monkey patching your code in a test environment means you are asserting a different behaviour than the normal one, thus missing the entire point of the test.</p>

  <p><em>BUT</em></p>

  <p>In some circumstances, testing the real behaviour is not your responsibility, and you should not do it. I'm talking about when the use of a library or framework asks you to write some code in your object making it a slave of two masters : You and the library writer.</p>

  <p>In those cases, you might want to patch your object to drop its relation to the library in order to test only the behaviour you have designed. It's a fragile thing since you're not testing the real object but it might still make sense when integrating tools from which an isolation layer is really hard and/or stupid to write.</p>

  <p>One of those cases is Devise.</p>

  <p>When testing a User object, or an object graph containing a User instance, We very often do not want anything Devise related. Devise is meant to be integrated directly into the User class code and in Order to remove it, we use the following patch :</p>

  <pre><code class="ruby"><span class="comment">#/spec/support/overrides/devise.rb</span>


  <span class="keyword">require</span> <span class="string">'active_record'</span>


  <span class="class"><span class="keyword">module</span> <span class="title">DeviseInhibitor</span></span>
    <span class="function"><span class="keyword">def</span> <span class="title">devise</span><span class="params">(*whatever)</span></span>
      attr_accessor <span class="symbol">:password</span>, <span class="symbol">:password_confirmation</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>


  <span class="constant">ActiveRecord::Base</span>.singleton_class.prepend <span class="constant">DeviseInhibitor</span>

  </code></pre>

  <p>Then we require this specific file in the example file.</p>

  <p>When using such overrides , we always require them manually so it's very explicit that the test is against a slightly drifted variation of the code.</p>

  <p>We already have used this technique with gems like geocoder, too which has the same integration pattern as devise.</p>

  <h3>/spec/support/shared_contexts</h3>

  <p>This folder is simply where we put globally known shared contexts. When a shared context is meant to be used in any kind of feature spec (like "Users with different roles exists", or "A concert will happen next week") we put the file here. We use shared_contexts as a kind of very powerful data fixtures : creating data and helper methods to access those data.</p>

  <p>Here is an example following the previous feature spec example. including this context create the expected records and allows us to use the <code>let</code> statement to access the data easily.</p>

  <pre><code class="ruby"><span class="comment"># /spec/support/shared_contexts/ticket_has_been_bought.rb</span>


  <span class="constant">RSpec</span>.shared_context <span class="string">'a ticket has been bought using bank transfer'</span> <span class="keyword">do</span>

    let(<span class="symbol">:ticket_concert</span>){ fail <span class="string">"please define the concert for which this ticket has been bought"</span> }
    let(<span class="symbol">:ticket_buyer</span>){ fail <span class="string">"please define the user who has bought the ticket"</span> }


    let(<span class="symbol">:ticket_price</span>){ <span class="number">100</span> }
    let(<span class="symbol">:vip_kind</span>){ <span class="constant">TickeType</span>.vip } <span class="comment"># we imagine those records are parts of the seed</span>

    let!(<span class="symbol">:ticket_transaction</span>) <span class="keyword">do</span>
      <span class="comment"># we imagine having a factory for this record</span>
      create(<span class="symbol">:ticket_transaction</span>,
        <span class="symbol">:bank_transfer</span>,
        <span class="symbol">:pending</span>
        issued_at<span class="symbol">:</span> <span class="number">3</span>.days.ago
        ....
      )
    <span class="keyword">end</span>

    let!(<span class="symbol">:ticket</span>) <span class="keyword">do</span>
      <span class="comment"># we imagine having a factory for this record</span>
      create(<span class="symbol">:ticket</span>,
        <span class="symbol">:signed</span>,
        user<span class="symbol">:</span> ticket_buyer,
        concert<span class="symbol">:</span> ticket_concert,
        price<span class="symbol">:</span> ticket_price,
        transaction<span class="symbol">:</span> ticket_transaction,
        ....
      )
    <span class="keyword">end</span>


  <span class="keyword">end</span>

  </code></pre>

  <h3>/spec/spec<em>helper.rb, /spec/rails</em>helper.rb, /spec/activerecord_spec.rb</h3>

  <p><code>/spec/spec_helper.rb</code> is the smallest, fastest initializer we can write for rspec. We use all the recommanded default setting, and add just 3 additional things :</p>

  <ul>

  <li><a href="https://github.com/rspec/rspec-collection_matchers">Collection Matchers</a> : Because we like their expressivity very much, and since all our rspec related gems are <code>require =&gt; false</code> in our gemfile , we require them here.</li>

  <li>Auto looading of usual rails files : Even when we do not start Rails we like being able to benefit from the autoloading of constants from files in the <code>app</code> directory.</li>

  <li>Defaulting the time zone : Because we have found the hard way that problems coming from machines having different default time zones are a pain to discover.</li>

  </ul>

  <p>So here is what we add to the default file :</p>

  <pre><code class="ruby"><span class="comment"># /spec/spec_helper.rb</span>

  <span class="keyword">require</span> <span class="string">'rspec/collection_matchers'</span>


  <span class="keyword">require</span> <span class="string">'active_support'</span>

  <span class="keyword">require</span> <span class="string">'active_support/core_ext'</span>

  <span class="keyword">require</span> <span class="string">'active_support/dependencies'</span>


  <span class="constant">Dir</span>[<span class="constant">File</span>.join(<span class="constant">File</span>.dirname(__FILE_<span class="number">_</span>), <span class="string">'..'</span>, <span class="string">'app'</span>, <span class="string">'models'</span>)].each { |f| <span class="constant">ActiveSupport::Dependencies</span>.autoload_paths &lt;&lt; f }

  <span class="constant">Dir</span>[<span class="constant">File</span>.join(<span class="constant">File</span>.dirname(__FILE_<span class="number">_</span>), <span class="string">'..'</span>, <span class="string">'app'</span>, <span class="string">'*'</span>)].each { |f| <span class="constant">ActiveSupport::Dependencies</span>.autoload_paths &lt;&lt; f }

  <span class="constant">Dir</span>[<span class="constant">File</span>.join(<span class="constant">File</span>.dirname(__FILE_<span class="number">_</span>), <span class="string">'..'</span>, <span class="string">'app'</span>, <span class="string">'*'</span>, <span class="string">'concerns'</span>)].each { |f| <span class="constant">ActiveSupport::Dependencies</span>.autoload_paths &lt;&lt; f }


  <span class="constant">Time</span>.zone_default= <span class="constant">Time</span>.find_zone!(<span class="string">'UTC'</span>)

  </code></pre>

  <p><code>/spec/rails_helper.rb</code> is the heaviest, initializer we can write for rspec. It boots the entire rails application and is used for feature spec. We load some rspec extensions we only have meaning for those kind of specs (i.e. webmock), and we load all the files described above (except the overrides of course).</p>

  <p>We also set the default rails application locale, in order to be sure that the test process and the server process have the same default. So here is our file :</p>

  <pre><code class="ruby"><span class="comment"># /spec/rails_helper.rb</span>


  <span class="constant">ENV</span>[<span class="string">'RAILS_ENV'</span>] ||= <span class="string">'test'</span>


  <span class="keyword">require</span> <span class="string">'spec_helper'</span>

  <span class="keyword">require</span> <span class="constant">File</span>.expand_path(<span class="string">'../../config/environment'</span>, __FILE_<span class="number">_</span>)

  <span class="keyword">require</span> <span class="string">'rspec/rails'</span>

  <span class="comment"># Add additional requires below this line. Rails is not loaded until this point!</span>

  <span class="keyword">require</span> <span class="string">'webmock'</span>

  <span class="keyword">require</span> <span class="string">'webmock/rspec'</span>

  <span class="constant">WebMock</span>.disable_net_connect!(<span class="symbol">:allow_localhost</span> =&gt; <span class="keyword">true</span>)


  <span class="comment"># Include all our custom setup</span>

  <span class="constant">Dir</span>[<span class="constant">Rails</span>.root.join(<span class="string">'spec/support/initializers/*.rb'</span>)].each { |f| <span class="keyword">require</span> f }

  <span class="constant">Dir</span>[<span class="constant">Rails</span>.root.join(<span class="string">'spec/support/pages/**/*.rb'</span>)].each { |f| <span class="keyword">require</span> f }

  <span class="constant">Dir</span>[<span class="constant">Rails</span>.root.join(<span class="string">'spec/support/helpers/*.rb'</span>)].each { |f| <span class="keyword">require</span> f }

  <span class="constant">Dir</span>[<span class="constant">Rails</span>.root.join(<span class="string">'spec/support/shared_contexts/*.rb'</span>)].each { |f| <span class="keyword">require</span> f }


  <span class="constant">ActiveRecord::Migration</span>.maintain_test_schema!


  <span class="constant">RSpec</span>.configure <span class="keyword">do</span> |config|
    config.use_transactional_fixtures = <span class="keyword">false</span>
    config.infer_spec_type_from_file_location!
  <span class="keyword">end</span>


  <span class="constant">I18n</span>.locale= <span class="symbol">:fr</span>

  </code></pre>

  <p><code>/spec/activerecord_spec.rb</code> is a custom helper for testing objects in almost isolation. We use a lot of plain old ruby objects in our apps but we do not want to completely isolate activerecord form the rest of the app only because it is tightly tied to a third party library. We accept this bound and follow the active record pattern : adding behaviour to objects representing database records. But then we need to test them of course and this doesn't mean we want to load the entire rails application with its routing, controllers, views, assets, etc.</p>

  <p>This is why we have this third helper :</p>

  <pre><code class="ruby"><span class="comment">#/spec/activerecord_spec.rb</span>

  <span class="keyword">require</span> <span class="string">'spec_helper'</span>


  <span class="keyword">require</span> <span class="string">'active_record'</span>

  <span class="keyword">require</span> <span class="string">'factory_girl'</span>

  <span class="keyword">require</span> <span class="string">'yaml'</span>


  db_configurations = <span class="constant">YAML::</span>load(<span class="constant">ERB</span>.new(<span class="constant">File</span>.read(<span class="string">"config/database.yml"</span>)).result)


  <span class="constant">ActiveRecord::Base</span>.send(<span class="symbol">:configurations</span>=, db_configurations)

  <span class="constant">ActiveRecord::Base</span>.establish_connection(<span class="symbol">:test</span>)


  require_relative <span class="string">"support/initializers/factory_girl"</span>

  require_relative <span class="string">"support/initializers/database_cleaner"</span>


  require_relative <span class="string">'support/overrides/devise'</span>

  </code></pre>

  <h2>Conclusion</h2>

  <p>This one is a long post but we hope you will find it interesting not only to understand the way we organize our files but also the real code we use. Those files are the result of a long path of small improvements and are in perpetual changes. There hasn't been any major change in the structure for a long time but every project we work on brings its new contraints and solutions.</p>

  <p>See you soon for the next and last article, <em>The flow</em>, where we will explain how we go from test to code and vice versa.</p>

  <p>Update : The next and last part is ready, you can find it <strong><a href="https://belighted.com/blog/how-we-test-our-rails-projects-3-3">here</a></strong></p>

  <p><!--HubSpot Call-to-Action Code --><span class="hs-cta-wrapper" id="hs-cta-wrapper-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2"><span class="hs-cta-node hs-cta-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2" id="hs-cta-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2"><!--[if lte IE 8]><div id="hs-cta-ie-element"></div><![endif]--><a href="https://cta-redirect.hubspot.com/cta/redirect/1684659/fb3606cc-cc1b-47d0-ae85-2c9f69837fe2" target="_blank"><img class="hs-cta-img" id="hs-cta-img-fb3606cc-cc1b-47d0-ae85-2c9f69837fe2" style="border-width:0px;" src="https://no-cache.hubspot.com/cta/default/1684659/fb3606cc-cc1b-47d0-ae85-2c9f69837fe2.png" alt="New Call-to-action"></a></span></span><!-- end HubSpot Call-to-Action Code --><iframe id="dsq-app1" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 0px !important;" tabindex="0" title="Disqus" xml="lang" src="https://disqus.com/embed/comments/?base=default&amp;version=105ec7c1b6b6b3960e72ac39bf0bd1c5&amp;f=belighted&amp;t_u=http%3A%2F%2Fbelighted.com%2Fblog%2Fhow-we-test-our-rails-projects-2-3&amp;t_d=How%20we%20test%20our%20Rails%20projects%20(2%2F3)&amp;t_t=How%20we%20test%20our%20Rails%20projects%20(2%2F3)&amp;s_o=default" name="dsq-app1" width="100%" height="150" frameborder="0" scrolling="no"></iframe></p>
tags:
  - label: Under the hood
    value: under-the-hood
